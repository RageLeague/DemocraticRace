local patch_id = "DUAL_PURPOSE_CARDS"
if rawget(_G, patch_id) then
    return
end
rawset(_G, patch_id, true)
print("Loaded patch:"..patch_id)

local FEATURES = {
    DUAL_PURPOSE_NEGOTIATION =
    {
        name = "Dual Purpose",
        desc = "At the beginning of a battle, insert the battle counterpart of this card into your deck, except they share uses, and this card is destroyed if the battle counterpart is destroyed.",
        feature_desc = "{DUAL_PURPOSE_NEGOTIATION}",
        feature_desc_fn = function(self, fmt_str, num, engine, card)
            if card.battle_counterpart then
                return fmt_str .. "{" .. card.battle_counterpart .. "|}"
            end
            return fmt_str
        end,
    },
}
for id, data in pairs(FEATURES) do
	local def = NegotiationFeatureDef(id, data)
	Content.AddNegotiationCardFeature(id, def)
end

local FEATURES =
{
    DUAL_PURPOSE_BATTLE =
    {
        name = "Dual Purpose",
        desc = "When this card is added to your battle deck, immediately remove it and gain the negotiation counterpart instead.",
        feature_desc = "{DUAL_PURPOSE_BATTLE}",
        feature_desc_fn = function(self, fmt_str, num, engine, card)
            if card.negotiation_counterpart then
                return fmt_str .. "{" .. card.negotiation_counterpart .. "|}"
            end
            return fmt_str
        end,
    },
}

for id, data in pairs( FEATURES ) do
    local def = BattleFeatureDef(id, data)
    Content.AddBattleCardFeature(id, def)
end

function Content.AutoGenerateDualPurpose()
    for i, card_def in ipairs(Content.GetAllNegotiationCards()) do
        if card_def.battle_counterpart then
            local battle_def = Content.GetBattleCard(card_def.battle_counterpart)
            if battle_def then
                if not battle_def.negotiation_counterpart then
                    battle_def.negotiation_counterpart = card_def.id
                end
                if battle_def.negotiation_counterpart ~= card_def.id then
                    print("WARNING: Unmatched dual purpose cards:", card_def.id, card_def.battle_counterpart)
                end
            end
        end
    end
    for i, card_def in ipairs(Content.GetAllBattleCards()) do
        if card_def.negotiation_counterpart then
            local negotiation_def = Content.GetNegotiationCard(card_def.negotiation_counterpart)
            if negotiation_def then
                if not negotiation_def.battle_counterpart then
                    negotiation_def.battle_counterpart = card_def.id
                end
                if negotiation_def.battle_counterpart ~= card_def.id then
                    print("WARNING: Unmatched dual purpose cards:", card_def.negotiation_counterpart, card_def.id)
                end
            end
        end
    end
    -- for i, card_def in ipairs(Content.GetAllNegotiationCards()) do
    --     if card_def.battle_counterpart then
    --         card_def.features = card_def.features or {}
    --         card_def.features.DUAL_PURPOSE_NEGOTIATION = 1
    --     end
    -- end
    -- for i, card_def in ipairs(Content.GetAllBattleCards()) do
    --     if card_def.negotiation_counterpart then
    --         card_def.features = card_def.features or {}
    --         card_def.features.DUAL_PURPOSE_BATTLE = 1
    --     end
    -- end
end

local function AllowsDualPurposeCards(card)
    local param = { val = false }
    TheGame:BroadcastEvent("allow_dual_purpose_cards", card, param)
    return param.val
end

local old_desc_fn = CardEngine.GenerateCardDesc

function CardEngine.GenerateCardDesc( card, ... )
    local allow_dual_purpose_cards = (card.negotiation_counterpart or card.battle_counterpart) and AllowsDualPurposeCards(card)
    local feature_id = (is_instance( card, BattleCardDef ) or is_instance( card, Battle.Card )) and "DUAL_PURPOSE_BATTLE" or "DUAL_PURPOSE_NEGOTIATION"
    if allow_dual_purpose_cards then
        card.features = card.features or {}
        card.features[feature_id] = 1
    end
    local result = old_desc_fn(card, ...)
    if allow_dual_purpose_cards then
        -- card.features = card.features or {}
        card.features[feature_id] = nil
    end
    return result
end

local old_battler_add_card = Aspect.Battler.AddCard

function Aspect.Battler:AddCard( card, ... )
    local res
    if old_battler_add_card then
        res = old_battler_add_card( self, card, ... )
    else
        res = Aspect.Battler._base.RemoveCard( self, card, ... )
    end
    if card.negotiation_counterpart and self.agent and self.agent.negotiator and AllowsDualPurposeCards() then
        self:RemoveCard(card)
        self.agent.negotiator:LearnCard(card.negotiation_counterpart)
    end
    return res
end

local old_create_fighter_fn = Fighter.CreateFromAgent

function Fighter.CreateFromAgent(agent, ...)
    local fighter = old_create_fighter_fn(agent, ...)
    if agent.battler and (fighter.behaviour == nil or player_controlled) then
        if agent.negotiator then
            for i, card in ipairs(agent.negotiator:GetCards()) do
                if card.battle_counterpart then
                    local battle_card = Battle.Card(card.battle_counterpart, card.owner, card.userdata)
                    battle_card.show_dealt = false
                    battle_card.owner = fighter
                    battle_card.linked_negotiation_counterpart = card
                    table.insert( fighter.cards, battle_card )
                end
            end
        end
    end
    return fighter
end

local old_consume_battle_card_fn = Battle.Card.Consume

function Battle.Card:Consume(...)
    old_consume_battle_card_fn(self, ...)

    local agent
    if is_instance( self.owner, Agent ) then
        agent = self.owner
    elseif is_instance( self.owner, Fighter ) then
        agent = self.owner.agent
    else
       print( self, "NO OWNER TO CONSUME:", self.owner )
    end

    if agent and agent.negotiator and self.linked_negotiation_counterpart then
        agent.negotiator:RemoveCard( self.linked_negotiation_counterpart )
    end
end

local old_on_added = Battle.Card.OnAdded

function Battle.Card:OnAdded(...)
    old_on_added(self, ...)
    if self.linked_negotiation_counterpart then
        self:MakeTemporary(false)
    end
end
